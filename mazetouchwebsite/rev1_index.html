<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze: Solve the World's Most Challenging Puzzle</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        #root {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // Lucide icons as inline SVG components
        const Info = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="16" x2="12" y2="12"></line>
                <line x1="12" y1="8" x2="12.01" y2="8"></line>
            </svg>
        );

        const X = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );

        const Home = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                <polyline points="9 22 9 12 15 12 15 22"></polyline>
            </svg>
        );

        const ZoomIn = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        );

        const ZoomOut = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        );

        const MazeViewer = () => {
            const [showModal, setShowModal] = useState(false);
            const [scale, setScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [dragThreshold, setDragThreshold] = useState(false);
            const [lastTap, setLastTap] = useState(0);
            const [currentRoom, setCurrentRoom] = useState(1);
            const [imageError, setImageError] = useState(false);
            
            const containerRef = useRef(null);
            const imageRef = useRef(null);
            
            // Sample room data - in a real implementation, this would come from the actual maze data
            const roomData = {
                1: {
                    text: `They looked carefully at the bronze doors, trying to choose. The uncertainty of visitors is one of my little pleasures.

"It's easy to get lost," I said helpfully. "This can be a sinister place." The sun glared at me through the gateway.

Something was ringing behind one of the doors. They spent some time trying to decide which door it was, not understanding that the silences of the Maze are as eloquent as the sounds.

"Decisions, decisions," one said. "Too many decisions."

"The story of my life," said another.

"We don't want to be late," said a third, opening one of the doors.

"Nary a soul to be seen," said the first, peering into the gloom.

I waited patiently for them to choose which way to go . . .`,
                    // Update this path to match your local file structure
                    image: './images/room1.jpg',
                    doors: [20, 26, 41, 21],
                    clickableAreas: [
                        { door: 20, coords: [150, 100, 270, 300] }, // x, y, width, height
                        { door: 26, coords: [530, 100, 650, 300] },
                        { door: 41, coords: [300, 350, 500, 500] },
                        { door: 21, coords: [100, 400, 250, 550] }
                    ]
                }
            };

            const room = roomData[currentRoom];

            // Handle mouse/touch start
            const handlePointerDown = (e) => {
                if (e.target.tagName === 'IMG' || e.target === containerRef.current) {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    setDragStart({
                        x: clientX - position.x,
                        y: clientY - position.y
                    });
                    setDragThreshold(false);
                    setIsDragging(true);
                }
            };

            // Handle mouse/touch move
            const handlePointerMove = (e) => {
                if (!isDragging) return;
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                const newX = clientX - dragStart.x;
                const newY = clientY - dragStart.y;
                
                // Check if we've moved enough to count as dragging
                if (!dragThreshold) {
                    const distance = Math.hypot(newX - position.x, newY - position.y);
                    if (distance > 5) {
                        setDragThreshold(true);
                        e.preventDefault();
                    }
                }
                
                if (dragThreshold) {
                    e.preventDefault();
                    setPosition({ x: newX, y: newY });
                }
            };

            // Handle mouse/touch end
            const handlePointerUp = () => {
                setIsDragging(false);
                setDragThreshold(false);
            };

            // Handle pinch zoom on touch devices
            const handleTouchStart = (e) => {
                if (e.touches.length === 2) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const distance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    containerRef.current.dataset.initialPinchDistance = distance;
                    containerRef.current.dataset.initialScale = scale;
                } else {
                    handlePointerDown(e);
                }
            };

            const handleTouchMove = (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const distance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    const initialDistance = parseFloat(containerRef.current.dataset.initialPinchDistance);
                    const initialScale = parseFloat(containerRef.current.dataset.initialScale);
                    
                    if (initialDistance) {
                        const newScale = initialScale * (distance / initialDistance);
                        setScale(Math.min(Math.max(0.5, newScale), 4));
                    }
                } else {
                    handlePointerMove(e);
                }
            };

            // Handle mouse wheel zoom
            const handleWheel = (e) => {
                e.preventDefault();
                const delta = e.deltaY * -0.001;
                const newScale = Math.min(Math.max(0.5, scale + delta), 4);
                setScale(newScale);
            };

            // Reset view
            const resetView = () => {
                setScale(1);
                setPosition({ x: 0, y: 0 });
            };

            // Zoom in/out buttons
            const zoomIn = () => {
                setScale(prev => Math.min(prev + 0.2, 4));
            };

            const zoomOut = () => {
                setScale(prev => Math.max(prev - 0.2, 0.5));
            };

            useEffect(() => {
                const container = containerRef.current;
                if (container) {
                    container.addEventListener('wheel', handleWheel, { passive: false });
                    return () => container.removeEventListener('wheel', handleWheel);
                }
            }, [scale]);

            // Reset position when changing rooms
            useEffect(() => {
                resetView();
                setImageError(false);
            }, [currentRoom]);

            // Create a placeholder SVG if image fails to load
            // Handle image click to navigate to rooms
            const handleImageClick = (e) => {
                // Only handle click if we haven't been dragging
                if (dragThreshold) return;
                
                if (!imageRef.current || imageError) return;
                
                // For touch devices, require double tap
                if (e.type === 'touchend' || e.nativeEvent?.pointerType === 'touch') {
                    const now = Date.now();
                    const timeSinceLastTap = now - lastTap;
                    
                    if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
                        // Double tap detected
                        handleRoomNavigation(e);
                        setLastTap(0);
                    } else {
                        // First tap
                        setLastTap(now);
                    }
                } else {
                    // Mouse click - single click
                    handleRoomNavigation(e);
                }
            };
            
            const handleRoomNavigation = (e) => {
                const rect = imageRef.current.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : (e.changedTouches ? e.changedTouches[0].clientX : e.clientX);
                const clientY = e.touches ? e.touches[0].clientY : (e.changedTouches ? e.changedTouches[0].clientY : e.clientY);
                
                const x = (clientX - rect.left) / (rect.width / imageRef.current.naturalWidth);
                const y = (clientY - rect.top) / (rect.height / imageRef.current.naturalHeight);
                
                // Check if click is within any clickable area
                const clickedArea = room.clickableAreas?.find(area => {
                    const [ax, ay, ax2, ay2] = area.coords;
                    return x >= ax && x <= ax2 && y >= ay && y <= ay2;
                });
                
                if (clickedArea) {
                    setCurrentRoom(clickedArea.door);
                }
            };

            const PlaceholderImage = () => (
                <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg" className="select-none">
                    <rect width="800" height="600" fill="#2d1810"/>
                    <rect x="50" y="50" width="700" height="500" fill="#3d2820" stroke="#8b6f47" strokeWidth="4"/>
                    
                    {/* Door frames */}
                    <rect x="150" y="100" width="120" height="200" fill="#1a0f0a" stroke="#8b6f47" strokeWidth="3"/>
                    <rect x="530" y="100" width="120" height="200" fill="#1a0f0a" stroke="#8b6f47" strokeWidth="3"/>
                    <rect x="300" y="350" width="200" height="150" fill="#1a0f0a" stroke="#8b6f47" strokeWidth="3"/>
                    
                    {/* Door numbers */}
                    <text x="210" y="210" fill="#d4af37" fontSize="48" fontFamily="serif" textAnchor="middle">20</text>
                    <text x="590" y="210" fill="#d4af37" fontSize="48" fontFamily="serif" textAnchor="middle">26</text>
                    <text x="400" y="435" fill="#d4af37" fontSize="48" fontFamily="serif" textAnchor="middle">41</text>
                    
                    {/* Title */}
                    <text x="400" y="50" fill="#d4af37" fontSize="32" fontFamily="serif" textAnchor="middle" fontWeight="bold">
                        Room {currentRoom}
                    </text>
                    
                    {/* Instruction text */}
                    <text x="400" y="570" fill="#8b6f47" fontSize="16" fontFamily="sans-serif" textAnchor="middle">
                        Check image path: ./images/room{currentRoom}.jpg
                    </text>
                </svg>
            );

            return (
                <div className="fixed inset-0 bg-gray-900 overflow-hidden">
                    {/* Image Container */}
                    <div
                        ref={containerRef}
                        className="w-full h-full cursor-move touch-none"
                        onMouseDown={handlePointerDown}
                        onMouseMove={handlePointerMove}
                        onMouseUp={handlePointerUp}
                        onMouseLeave={handlePointerUp}
                        onTouchStart={handleTouchStart}
                        onTouchMove={handleTouchMove}
                        onTouchEnd={handlePointerUp}
                    >
                        <div
                            style={{
                                transform: `translate(${position.x}px, ${position.y}px) scale(${scale})`,
                                transformOrigin: 'center center',
                                transition: isDragging ? 'none' : 'transform 0.1s ease-out',
                                width: '100%',
                                height: '100%',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center'
                            }}
                        >
                            {imageError ? (
                                <PlaceholderImage />
                            ) : (
                                <img
                                    ref={imageRef}
                                    src={room.image}
                                    alt={`Room ${currentRoom}`}
                                    className="max-w-full max-h-full object-contain select-none cursor-pointer"
                                    draggable="false"
                                    onError={() => setImageError(true)}
                                    onClick={handleImageClick}
                                    onTouchEnd={handleImageClick}
                                    style={{ pointerEvents: 'auto' }}
                                />
                            )}
                        </div>
                    </div>

                    {/* Info Button */}
                    <button
                        onClick={() => setShowModal(true)}
                        className="fixed top-4 right-4 bg-amber-600 hover:bg-amber-700 text-white p-3 rounded-full shadow-lg transition-colors z-50"
                        aria-label="Show room description"
                    >
                        <Info size={24} />
                    </button>

                    {/* Home/Reset Button */}
                    <button
                        onClick={resetView}
                        className="fixed top-4 left-4 bg-gray-700 hover:bg-gray-600 text-white p-3 rounded-full shadow-lg transition-colors z-50"
                        aria-label="Reset view"
                    >
                        <Home size={24} />
                    </button>

                    {/* Zoom Controls */}
                    <div className="fixed top-20 right-4 flex flex-col gap-2 z-50">
                        <button
                            onClick={zoomIn}
                            className="bg-gray-700 hover:bg-gray-600 text-white p-3 rounded-full shadow-lg transition-colors"
                            aria-label="Zoom in"
                        >
                            <ZoomIn size={20} />
                        </button>
                        <button
                            onClick={zoomOut}
                            className="bg-gray-700 hover:bg-gray-600 text-white p-3 rounded-full shadow-lg transition-colors"
                            aria-label="Zoom out"
                        >
                            <ZoomOut size={20} />
                        </button>
                    </div>

                    {/* Zoom Indicator */}
                    <div className="fixed bottom-4 left-4 bg-gray-800 bg-opacity-80 text-white px-3 py-2 rounded-lg text-sm z-50">
                        Zoom: {Math.round(scale * 100)}%
                    </div>

                    {/* Room Navigation */}
                    <div className="fixed bottom-4 right-4 bg-gray-800 bg-opacity-80 text-white px-4 py-2 rounded-lg z-50">
                        <div className="text-xs mb-1 opacity-70">Room {currentRoom}</div>
                        <div className="text-xs opacity-70">
                            Doors: {room.doors.join(', ')}
                        </div>
                    </div>

                    {/* Modal */}
                    {showModal && (
                        <div
                            className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50"
                            onClick={() => setShowModal(false)}
                        >
                            <div
                                className="bg-amber-50 rounded-lg max-w-2xl w-full max-h-[80vh] overflow-y-auto shadow-2xl"
                                onClick={(e) => e.stopPropagation()}
                            >
                                <div className="sticky top-0 bg-amber-100 border-b-2 border-amber-300 p-4 flex justify-between items-center">
                                    <h2 className="text-2xl font-serif text-amber-900">
                                        Room {currentRoom}
                                    </h2>
                                    <button
                                        onClick={() => setShowModal(false)}
                                        className="text-amber-900 hover:text-amber-700 transition-colors"
                                        aria-label="Close modal"
                                    >
                                        <X size={28} />
                                    </button>
                                </div>
                                <div className="p-6">
                                    <div className="text-gray-800 leading-relaxed whitespace-pre-line font-serif text-lg">
                                        {room.text}
                                    </div>
                                    <div className="mt-6 pt-6 border-t border-amber-300">
                                        <div className="text-sm text-amber-900 font-semibold mb-2">
                                            Available Doors:
                                        </div>
                                        <div className="flex flex-wrap gap-2">
                                            {room.doors.map(door => (
                                                <button
                                                    key={door}
                                                    onClick={() => {
                                                        setCurrentRoom(door);
                                                        setShowModal(false);
                                                    }}
                                                    className="bg-amber-600 hover:bg-amber-700 text-white px-4 py-2 rounded transition-colors font-semibold"
                                                >
                                                    Room {door}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Instructions overlay */}
                    <div className="fixed top-20 left-1/2 transform -translate-x-1/2 bg-gray-800 bg-opacity-90 text-white px-6 py-3 rounded-lg text-sm text-center pointer-events-none z-40 max-w-md">
                        <div className="font-semibold mb-1">Controls</div>
                        <div className="text-xs opacity-90">
                            Desktop: Click doors • Drag to pan • Scroll to zoom<br/>
                            Touch: Double-tap doors • Drag to pan • Pinch to zoom
                        </div>
                        {imageError && (
                            <div className="text-xs text-amber-400 mt-2">
                                Image not found - check the path in the code
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        ReactDOM.render(<MazeViewer />, document.getElementById('root'));
    </script>
</body>
</html>